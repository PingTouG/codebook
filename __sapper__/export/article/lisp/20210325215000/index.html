<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=assets/styles/global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{},{page:{title:"第二章：REPL简介",slug:"Lisp",time:"2021-03-25T21:52:34.000Z",author:"PingTouG",html:"\u003Cp\u003Ecommon lisp 源文件扩展名一般为.lisp 或.cl\u003C\u002Fp\u003E\n\u003Cp\u003Eemacs 命令：C-c C-q 调用：slime-close-parens-at-point。将插入必要数量的闭括号以匹配当前的所有开括号。\u003C\u002Fp\u003E\n\u003Cp\u003Eemacs 命令：C-c C-c 可以编译光标所在的当前 lisp 代码\u003C\u002Fp\u003E\n\u003Cp\u003Eemacs 命令：C-c C-z 可以回到 REPL(lisp 编译环境)\u003C\u002Fp\u003E\n\u003Cp\u003Eemacs 命令：在 REPL 中输入逗号，则在 emacs 底部输入 quit 或 sayoonara，回车即可退出 REPL。\u003C\u002Fp\u003E\n\u003Cp\u003Eemacs 命令：从调试器中退出：q\u003C\u002Fp\u003E\n\u003Cp\u003E在 REPL 中使用 load 可加载 lisp 文件。加载完成之后则文件中的代码就被编译了。\n如：(load &quot;test.lisp&quot;)\u003C\u002Fp\u003E\n\u003Cp\u003E加载文件中有用定义的方法：先用 compile-file 编译，然后再用 load 加载编译后产生的文件，即 FASL 文件(快速加载文件)\n如：(load (compile-file &quot;test.lisp&quot;))\u003C\u002Fp\u003E\n\u003Cp\u003Eeamcs 命令：C-c C-l 调用 slime-load-file。加载文件\nemacs 命令：C-c C-k 可以编译并加载那个当前缓冲区所关联的文件\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.ac5247b3.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.5.js";s.setAttribute("data-main","/client/client.ac5247b3.js")}document.head.appendChild(s)</script> <link href=client/client-5905f011.css rel=stylesheet><link href=client/_layout-8d114d53.css rel=stylesheet><link href=client/[...slug]-bb07c72b.css rel=stylesheet> <title>第二章：REPL简介</title> <link href=/client/client.ac5247b3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-5905f011.css rel=preload as=style><link href=/client/[...slug].9491a532.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/utils.302b01ae.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[...slug]-bb07c72b.css rel=preload as=style></head> <body> <div id=sapper> <section class=svelte-r1sizb><header class=svelte-r1sizb><a href=./ ><img alt="code book logo" class="svelte-r1sizb logo" src=/assets/images/logo.png></a> <a href=https://github.com/PingTouG class="svelte-r1sizb github" target=_blank><i class="svelte-r1sizb icon-github iconfont"></i></a></header> <main><section><main class=svelte-he2wxq> <section class=md><h1 class=title>第二章：REPL简介</h1> <div class="svelte-4z8ncs info"><div class="svelte-4z8ncs author">作者：PingTouG</div> <div class=time>时间：2021-03-25 21:52:34</div></div> <div class=md-content><p>common lisp 源文件扩展名一般为.lisp 或.cl</p> <p>emacs 命令：C-c C-q 调用：slime-close-parens-at-point。将插入必要数量的闭括号以匹配当前的所有开括号。</p> <p>emacs 命令：C-c C-c 可以编译光标所在的当前 lisp 代码</p> <p>emacs 命令：C-c C-z 可以回到 REPL(lisp 编译环境)</p> <p>emacs 命令：在 REPL 中输入逗号，则在 emacs 底部输入 quit 或 sayoonara，回车即可退出 REPL。</p> <p>emacs 命令：从调试器中退出：q</p> <p>在 REPL 中使用 load 可加载 lisp 文件。加载完成之后则文件中的代码就被编译了。 如：(load "test.lisp")</p> <p>加载文件中有用定义的方法：先用 compile-file 编译，然后再用 load 加载编译后产生的文件，即 FASL 文件(快速加载文件) 如：(load (compile-file "test.lisp"))</p> <p>eamcs 命令：C-c C-l 调用 slime-load-file。加载文件 emacs 命令：C-c C-k 可以编译并加载那个当前缓冲区所关联的文件</p> </div> </section></main> </section></main> <div class="back-top svelte-1m03zpm" style=bottom:5rem;right:.625rem;display:none><i class="iconfont icon-back-top"></i> </div> </section></div> 